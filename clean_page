#!/usr/bin/python
 # vim: set ts=2 expandtab:
"""
Module: clean_page
Desc: initial cleanup and non text removal for raw manga scan
Author: John O'Neil
Email: oneil.john@gmail.com
DATE: Sunday, August 4th 2012

  Input a manga raw scan image.
  Output three things:
  1. A binary version of the original image
  2. a binary mask where 1 is text, 0 not
  3. a cleaned version of the original image
    with the mask applied (i.e. text only)
  binary represents (as much as possible)
  text only.
  This is a tough problem, but this file
  represents my best solution so far.

  Subsequent tooling and processing should
  seqment the resultant image and masks
  for text isolation into lines and OCR. 
  
"""

import numpy as np
import cv2
import sys
import scipy.ndimage
from pylab import zeros,amax,median

def area_bb(a):
  return np.prod([max(x.stop-x.start,0) for x in a[:2]])
def area_nz(slice, image):
  return np.count_nonzero(image[slice])

def get_connected_components(image):
  s = scipy.ndimage.morphology.generate_binary_structure(2,2)
  labels,n = scipy.ndimage.measurements.label(image,structure=s)
  objects = scipy.ndimage.measurements.find_objects(labels)
  return objects  

def bounding_boxes(image,connected_components,max_size,min_size):
  mask = zeros(image.shape,'B')
  for component in connected_components:
    if area_bb(component)**.5<min_size: continue
    if area_bb(component)**.5>max_size: continue
    #a = area_nz(component,image)
    #if a<min_size: continue
    #if a>max_size: continue
    mask[component] = 1
  return mask

def cc_masks(image,connected_components,max_size,min_size):
  mask = zeros(image.shape,'B')
  for component in connected_components:
    if area_bb(component)**.5<min_size: continue
    if area_bb(component)**.5>max_size: continue
    #a = area_nz(component,image)
    #if a<min_size: continue
    #if a>max_size: continue
    mask[component] = image[component]>0
    #print str(mask[component])
  return mask

def draw_bounding_boxes(img,connected_components,max_size,min_size,color=(0,0,255),line_size=2):
  for component in connected_components:
    if area_bb(component)**0.5<min_size: continue
    if area_bb(component)**0.5>max_size: continue
    #a = area_nz(component,img)
    #if a<min_size: continue
    #if a>max_size: continue
    (ys,xs)=component[:2]
    cv2.rectangle(img,(xs.start,ys.start),(xs.stop,ys.stop),color,line_size)

def filter_by_black_white_ratio(img,connected_components,maximum=1.0,minimum=0.0):
  filtered = []
  for component in connected_components:
    black = area_nz(component,img)
    a = area_bb(component) 
    percent_black = float(black)/float(a)
    if percent_black < minimum or percent_black > maximum:
      print 'component removed for percent ' + str(percent_black)
      continue
    filtered.append(component)
  return filtered

def clean_page(img, max_scale=4.0, min_scale=0.15):
  #img = cv2.imread(sys.argv[1])
  (h,w,d)=img.shape

  gray = grayscale(img)

  #create gaussian filtered and unfiltered binary images
  gaussian_filtered = scipy.ndimage.gaussian_filter(gray, sigma=1.5)
  gaussian_binary = binarize(gaussian_filtered)
  binary = binarize(gray)
  
  #Draw out statistics on average connected component size in the rescaled, binary image
  average_size = average_CC_size(gaussian_binary)
  max_size = average_size*4.0
  min_size = average_size*0.15

  #primary mask is connected components filtered by size
  mask = form_CC_mask(gaussian_binary, max_size, min_size)

  #secondary mask is formed from canny edges
  canny_mask = form_canny_mask(gaussian_filtered, mask=mask)

  #final mask is size filtered connected components on canny mask
  final_mask = form_CC_mask(canny_mask, max_size, min_size)
  
  #apply mask and return images
  cleaned = cv2.bitwise_not(final_mask * cv2.bitwise_not(gray))
  return (cv2.bitwise_not(binary), final_mask, cleaned)

def clean_image_file(filename):
  img = cv2.imread(filename)
  return clean_page(img)

def grayscale(img):
  gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
  return gray

def binarize(img, threshold=190, white=255):
  (t,binary) = cv2.threshold(img, threshold, white, cv2.THRESH_BINARY_INV )
  return binary

def average_CC_size(img):
  components = get_connected_components(img)
  sorted_components = sorted(components,key=area_bb)
  #sorted_components = sorted(components,key=lambda x:area_nz(x,binary))
  areas = zeros(img.shape)
  for component in sorted_components:
    if amax(areas[component])>0: continue
    areas[component] = area_bb(component)**0.5
    #areas[component]=area_nz(component,binary)
  average_size = median(areas[(areas>3)&(areas<100)])
  return average_size

def form_CC_mask(img, max_size, min_size):
  components = get_connected_components(img)
  sorted_components = sorted(components,key=area_bb)
  mask = bounding_boxes(img,sorted_components,max_size,min_size)
  return mask

def form_canny_mask(img, mask=None):
  edges = cv2.Canny(img, 128, 255, apertureSize=3)
  if mask is not None:
    mask = mask*edges
  contours,hierarchy = cv2.findContours(mask,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)

  temp_mask = np.zeros(img.shape,np.uint8)
  for c in contours:
    #also draw detected contours into the original image in green
    cv2.drawContours(img,[c],0,(0,255,0),1)
    hull = cv2.convexHull(c)
    cv2.drawContours(temp_mask,[hull],0,255,-1)
  return temp_mask


if __name__ == '__main__':

  #this experiment relies upon a single input argument
  if len(sys.argv)<2:
    print 'USAGE clean_page <input image name>'
    sys.exit(-1)
  
  (binary,mask,cleaned) = clean_image_file(sys.argv[1])
  

  cv2.imshow('binary',binary)
  #cv2.imshow('mask',mask)
  cv2.imshow('cleaned',cleaned)
  cv2.imwrite(sys.argv[1]+'.binary.png', binary)
  cv2.imwrite(sys.argv[1]+'.cleaned.png',cleaned)

  if cv2.waitKey(0) == 27:
    cv2.destroyAllWindows()
  cv2.destroyAllWindows()
